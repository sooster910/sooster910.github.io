<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://sooster910.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sooster910.github.io/" rel="alternate" type="text/html" /><updated>2021-04-13T10:53:05+00:00</updated><id>https://sooster910.github.io/feed.xml</id><title type="html">Hyunsu</title><subtitle>Hi 👋  Front End Developer with an passion about JavaScript, Node.js, MongoDB. Interested in building a web app real-time and bidirectional communication.
</subtitle><author><name>Hyunsu Joo</name></author><entry><title type="html">[DataStructure] Array (static,dynamic array)</title><link href="https://sooster910.github.io/2021/02/02/algorithm-array.html" rel="alternate" type="text/html" title="[DataStructure] Array (static,dynamic array)" /><published>2021-02-02T00:00:00+00:00</published><updated>2021-02-02T00:00:00+00:00</updated><id>https://sooster910.github.io/2021/02/02/algorithm-array</id><content type="html" xml:base="https://sooster910.github.io/2021/02/02/algorithm-array.html">&lt;ul&gt;
  &lt;li&gt;자료구조 Array를 공부하며 남긴 글입니다. 오타나 설명이 잘 못되었다거나 조금 더 보충설명이 필요하시다고 생각되시면 댓글 남겨 주세요 언제든지 환영입니다 😄&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;#1.-Array&quot;&gt;1. Array&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#2.-Static-Array-vs-Dynamic-Array&quot;&gt;2. Static Array vs Dynamic Array &lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#2.1-Access&quot;&gt;2.1. Access&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#2.2-Appending&quot;&gt;2.2. Append&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#2.3-Insertion&quot;&gt;2.3. Insertion&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#2.4-Deletion&quot;&gt;2.4. Deletion&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#2.5-Time-Complexity&quot;&gt;2.5. Time Complexity&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-array&quot;&gt;1. Array&lt;/h2&gt;

&lt;p&gt;배열은 선형자료구조의 대표적인 예로써 지정한 배열의 크기만큼 연속된 메모리 공간을 할당 받는다.&lt;/p&gt;

&lt;p&gt;✔️ 선형자료구조 : 데이터가 순차적으로 나열된다는 의미이다.&lt;br /&gt;
✔️ 배열의 크기만큼 연속된 메모리 공간을 할당 받는다 : 
 일단 배열의 크기와 메모리공간의 상관관계를 알 필요가 있다. 예를 들어 C언어에서 int arr[4]= {1,2,3,4} 로 크기가 4인 integer형을 가진 배열을 선언했다고 하자. 32bit 시스템이라고 간주했을 때, integer는 하나의 숫자에 4byte의 메모리를 할당 받는다. 배열은 데이터형이 같으므로 4(element 개수) * 4(byte)= 16 byte의 메모리 주소를 할당 받는다. 연속된 메모리 공간을 할당 받으므로, 그림과 같이 16개의 연속된 공간을 차지 한다.&lt;/p&gt;

&lt;p&gt;위의 글로 미루어 보아 배열의 특징을 정리해 보자면,&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- 연속된 메모리 공간에 순차적으로 저장 (a contiguous block of memory)
- 배열은 선언시에 크기를 미리 정한다. 변경 할 수 없다.
- 배열에 들어갈 요소들의 데이터형은 동일해야 한다.
- 배열의 크기는 컴파일시에 결정되며 스택에 할당된다. (c언어, java)
- 배열 인덱스는 값에 대한 유일무이한 식별자
- 그러므로 인덱스 번호로 빠른접근이 가능, 즉 데이터의 위치에 대해 직접적인 접근이 가능하다. (Random Access)
- 하지만 요소값을 찾는 경우, 한번에 접근이 불가능하고 인덱스 0 부터 순회를 해서 찾아야함. 시간이 걸린다.  
- 때로 너무 많은 영역을 할당하여 낭비하는 현상이 생김.
- 너무 작은 영역을 할당하여 모자라는 현상 생김
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;2-static-array-vs-dynamic-array&quot;&gt;2. Static Array vs Dynamic Array&lt;/h2&gt;

&lt;p&gt;정적 배열과 동적 배열의 구분을 짓는 요소는 사이즈 변경이 가능한지에 대한 여부이다. 
위에서의 일반적인 배열의 특징으론 사이즈를 지정해야 하고 리사이즈가 불가능 하다 했다. 이것이 정적배열의 특징이며, 이런 정적배열의 한계점을 보완한 것이 동적배열이다. 즉 리사이즈가 가능함과 동시에 사이즈를 미리 지정할 필요가 없다. 동적배열의 내부적 원리는, 사이즈가10 인 정적배열이 초기화 되었다 했을때, 11번째 element를 배열에 추가 할 때는 메모리에서 11번째를 수용할 수 있는 더 큰 사이즈의 새 배열을 만들고 기존 배열의 요소를 모두 복사하여 새 배열에 붙인다. 그리고 기존의 배열은 메모리에서 삭제한다. 이런식의 작업을 반복한다. 결국 기존의 정적 배열(사이즈를 미리 정함)에서 길이를 초과한 경우엔 할당할 메모리를 늘리고 기존배열 요소를 모두 복사해서 새배열에 결합하는 방식의 반복이다. 파이썬의 list, 자바의 ArrayList, 그리고 C언어 vector가 동적배열 예이다. 파이썬의 경우, 우리가 list를 사용하여 코딩할 땐 실질적으로 동적배열의 과정을 잘 느끼지 못하지만,  파이썬 또한 C 언어를 기반으로 만들어졌기 때문에, List가 내부적으론 동적배열의 원리가 이용되었다고 말할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;21-access&quot;&gt;2.1 Access&lt;/h3&gt;

&lt;p&gt;동적배열 또한 정적배열과 같이 초기엔 배열의 크기를 지정하므로, 배열이 시작하는 지점의 메모리주소는 배열의 첫번째 요소의 메모리 주소와 일치하므로, 인덱스에 따른 메모리 주소를 찾는게 쉽다. 그래서 인덱싱이 빠르다.&lt;/p&gt;

&lt;h3 id=&quot;22-appending&quot;&gt;2.2 Appending&lt;/h3&gt;
&lt;p&gt;배열에서 공간이 남아 있는 경우, 정적배열,동적배열 모두 미리 할당된 크기 메모리안에서 요소를 추가 하는 것은 상수 비용이 든다 O(1).
다른 케이스로 동적배열에서 공간이 남아 있지 않은 경우에 추가를 하게 되면 &lt;strong&gt;분할상관분석&lt;/strong&gt;에 따른 분할상환시간은 O(1)이 된다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;&lt;strong&gt;분할상관분석&lt;/strong&gt;&lt;br /&gt;
위키피디아에 따르면 “어떠한 임의의 알고리즘에 대해서, 어떤 연산은 자원적 측면에서 상당한 비용을 소모할 수 있지만, 반면 다른 연산은 그렇게 고비용을 소모하지 않을 수 있다. 분할상환 분석은 알고리즘의 전반적인 연산 집합에 대해 비용이 높은 연산, 그리고 비용이 덜한 연산 모두를 함께 고려하는 기법이라 하겠다.”
Java의 ArrayList, C++ std의  vector, python의 list 와 같은 동적배열이 대표적인 예이다.
동적배열의 원리로 큰 용량의 메모리를 확보한다음 기존배열의 요소들을 다시 복사해서 옮기는 과정은 비용이 많이 소요되므로 O(n), 그 이후 다시 삽입하는 비용은 O(1)로 반복된다. 그리고 더블링(사이즈를 늘리는  연산)은 가끔 발생하므로, O(n)만으로 정의를 내리기가 어렵다. 그래서 분할상관분석 따른 전체적인 비용은 높지 않기 때문에 분할상환시간은 O(1)이 된다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;23-insertion&quot;&gt;2.3 Insertion&lt;/h3&gt;
&lt;p&gt;동적배열의 경우 배열이 꽉 차 있는 상태에서 삽입을 하게 배열 중간에 삽입이 필요하다면, 사이즈가 더 큰 새로운 배열을 만들어 기존의 요소들을 복사하고 새로운 요소를 원하는 인덱스에 삽입하는 방법을 접근한다. 기존요소들을 모두 복사하여 옮기는 시간복잡도는 O(n)라 볼 수 있다. 기존 메모리에 필요한 만큼 더 확장하지 않고 새로운 배열을 만드는 이유는 메모리에서 배열을 확장할 공간만큼의 공간이 있는지 알 수 없기 때문이다. 다른 변수의 메모리가 이미 차여있을 수도 있다.  &lt;br /&gt;
배열이 다 차 있지 않은 상태일 때는, 새로 삽입하려는 인덱스의 다음 인덱스 요소부터 하나씩 밀려, 삽입하려는 인덱스의 공간을 만들어준다. 제일 비용이 많이 발생하는 케이스는 인덱스가 0인 공간에 요소를 삽입할 때이다. 100개의 요소에서 100개의 요소 모두가 하나하나씩 다음인덱스로 옮겨 첫번째 인덱스를 빈 공간으로 만들어줘야 한다. 시간복잡도는 O(n)이 된다.&lt;/p&gt;

&lt;h3 id=&quot;24-deletion&quot;&gt;2.4 Deletion&lt;/h3&gt;
&lt;p&gt;직관적으로 본다면 정적배열에서는 삭제가 안된다. 동적배열에서는 맨 뒤의 요소를 삭제할 시에는 O(1) 의 복잡도가 걸린다.
그 이유는 삭제시 어떤 요소도 움직이지 않아도 되기 때문이다. 최악의 경우는 맨앞의 요소를 삭제 할때이다. 인덱스가 0인 요소가 삭제시 나머지 뒤에 있는 모든 요소들이 인덱스를 한칸 씩 앞으로 당겨 인덱스 0인 공간을 채워줘야 한다. 모든 인덱스가 움직이는데 드는 시간복잡도는 O(n)라 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;25-complexity&quot;&gt;2.5 Complexity&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;static array&lt;/th&gt;
      &lt;th&gt;dynamic array&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Access&lt;/td&gt;
      &lt;td&gt;O(1)&lt;/td&gt;
      &lt;td&gt;O(1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Search&lt;/td&gt;
      &lt;td&gt;O(n)&lt;/td&gt;
      &lt;td&gt;O(n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Insertion&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;O(n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Appending&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;분할상환분석에 따른 O(1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Deletion&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;맨 뒤 - O(1), 맨 앞,중간 - O(n)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;참고자료&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/implementation-of-dynamic-array-in-python/&quot; target=&quot;_blank&quot;&gt;geeksforgeeks.org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%B6%84%ED%95%A0%EC%83%81%ED%99%98%EB%B6%84%EC%84%9D&quot; target=&quot;_blank&quot;&gt;wikipedia.org/분할상환분석&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/PEnFFiQe1pM&quot; target=&quot;_blank&quot;&gt;https://youtu.be/dynamic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[도서 - 박성길, 2020, 파이썬 알고리즘 인터뷰, 책만 ]&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hyunsu Joo</name></author><category term="DataStructure" /><category term="Array" /><category term="staticArray" /><category term="dynamicArray" /><summary type="html">자료구조 Array를 공부하며 남긴 글입니다. 오타나 설명이 잘 못되었다거나 조금 더 보충설명이 필요하시다고 생각되시면 댓글 남겨 주세요 언제든지 환영입니다 😄</summary></entry><entry><title type="html">[DataStructure/Algorithm] JavaScript Recursive 재귀 알고리즘 제대로 이해하기 [1]</title><link href="https://sooster910.github.io/2020/11/03/recursive.html" rel="alternate" type="text/html" title="[DataStructure/Algorithm] JavaScript Recursive 재귀 알고리즘 제대로 이해하기 [1]" /><published>2020-11-03T00:00:00+00:00</published><updated>2020-11-03T00:00:00+00:00</updated><id>https://sooster910.github.io/2020/11/03/recursive</id><content type="html" xml:base="https://sooster910.github.io/2020/11/03/recursive.html">&lt;ul&gt;
  &lt;li&gt;오타나 설명이 잘 못되었다거나 보충설명이 필요하시다고 생각되시면 댓글 남겨 주세요 언제든지 환영입니다 😄&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;재귀함수란&quot;&gt;재귀함수란?&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
재귀함수의 아이디어는 어떤 함수가 있는데, 그 함수를 계속해서 호출하는 것이다 (자기자신을 재호출 하는 함수). 어떻게 호출하냐면 함수 내의 return값을 같은 함수로 정의 하여 다시 부르는 셈이다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;recursion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;recursion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;아래에서 재귀함수가 어떻게 동작하는지에 대해 좀 더 자세히 언급할 것이다.&lt;/p&gt;

&lt;!-- ## 재귀 왜 중요하죠? 어디에 쓰이죠?

재귀함수는 어디에나 쓰인다. 많이 쓰이기 때문에 그만큼 중요하다고 생각한다. 심지어 우리가 재귀함수를 써놓고도 재귀함수인줄 모르고 쓰는 경우도 있다. 

자바스크립트에서 Ajax 통신 할 때, JSON.parse / JSON.stringfy 를 쓰는데  

JSON.parse 를 이루는 코드가 대부분 재귀를 이용한 함수가 많이 쓰여졌다.

document.getElementById,
DOM traversal algorithms
에서도 쓰인다.  --&gt;

&lt;h2 id=&quot;재귀함수는-콜스택에서-어떻게-동작하는가&quot;&gt;재귀함수는 콜스택에서 어떻게 동작하는가?&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
1부터 3까지의 합을 구하는 함수이다. 지금 이 재귀함수가 합을 구하는 일에서는 효율적인 알고리즘은 아니지만 쉽게 이해하기 위해 재귀함수를 써보았다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3+2+1 =6&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수가 콜스택에서 어떻게 동작하는지 좀 더 쉽게 이해하기 위해 순서를 그려보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/recursion.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;콜스택은 함수의 호출을 기록하는 자료구조로써, 함수가 실행되면 이 호출 스택에 하나씩 쌓이고, 함수로부터 return 구문을 통해서 호출스택으로부터 함수가 마지막에 들어온 것 부터 반환된다.
자바스크립트에선 배열에서 push( ), pop( ) 이 스택의 동작과 일치한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function sum (3)&lt;/code&gt; 이 호출되면, 콜스택에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(3)&lt;/code&gt;이 쌓이고, 아래로 코드를 실행시켜 나간다. 그 다음 라인인 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if(num === 1) return 1&lt;/code&gt; num은 3이기 때문에, 그 다음라인으로 이동한다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return num + sum(num-1)&lt;/code&gt; return문이 나왔다. 이제 호출스택에서 빠져 나갈 찬스가 생겼다. 하지만 return 구문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3+sum(2)&lt;/code&gt;는 완전한 값이 아닌, 함수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(2)&lt;/code&gt; 을 포함 하고 있으므로, 콜스택에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(3)&lt;/code&gt;은 반환되지 못하고, 그 상태에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(2)&lt;/code&gt; 함수를 호출한다. 결국 return문에 값이 나올 때 까지 호출스택에 그대로 남게 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(2)&lt;/code&gt;함수를 호출하는 순간, 콜스택엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(2)&lt;/code&gt;가 추가가 된다. 그 다음 라인인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if(num === 1) return 1&lt;/code&gt; false 이므로, 그 다음라인으로 이동한다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return num+sum(num-1)&lt;/code&gt; return 구문이 나왔으므로, 호출스택에서 다시 빠져 나갈 찬스가 생겼다. 하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return 2+sum(1)&lt;/code&gt;은 완전한 값이 아니라 함수가 포함 되어있으므로, sum(1)을 호출 시킨다. 
콜스택엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(1)&lt;/code&gt;이라는 새로운 함수가 추가로 쌓이게 되고, 다음 라인을 실행한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if(num === 1) return 1;&lt;/code&gt; num=1 로써 true 이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return 1&lt;/code&gt;이 실행되면서 드디어 return을 하게 되었다. 콜스택에선 이제 맨위에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(1)&lt;/code&gt;을 반환한다. 
남아있는 호출 스택 중 맨 위에 있는 스택은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(2)&lt;/code&gt; sum(2)의 return문 에는 num+sum(2)=1+2=3 이 리턴되고 콜스택에서도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(2)&lt;/code&gt;가 빠진다. 마지막 남은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(3)&lt;/code&gt;은 return값으로 num+sum(3)=3+3=6이 리턴되면서 콜스택에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(3)&lt;/code&gt;도 빠진다. 마지막으로 빈 콜스택이 남게 된다.&lt;/p&gt;

&lt;p&gt;이 과정이, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(3)&lt;/code&gt; 재귀 함수가 호출되어 반환값을 내기 까지의 과정이다.
여기서 재귀함수를 구현 할 때 중요하게 봐야 할 두가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.기저 조건문 (base case)&lt;/li&gt;
  &lt;li&gt;2.새로운 input&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1기저-조건문-base-case&quot;&gt;1.기저 조건문 (base case)&lt;/h3&gt;

&lt;p&gt;sum(3) 함수 안에 if 구문이 빠진 상태로 호출 하게 된다면?&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum(num-1)&lt;/code&gt;이 끝도 없이 무한정으로 실행된다. 참고로 크롬브라우저는 최대 16000 프레임의 스택을 가지고 있는데, 이 최대 범위를 넘게 되면, 다음과 같이 콜스택 사이즈를 초과하였다는 에러를 만나게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/recursion1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우리가 어플리케이션을 실행할 때, 수많은 함수를 실행하는데, 위의 함수가 수많은 함수중에 하나라고 한다면, sum()는 계속 해서 호출하고 다음 동작(함수) 로 넘어갈 수가 없고 결국 어플리케이션은 freeze가 되는 현상을 겪게 된다.&lt;/p&gt;

&lt;p&gt;이런 무한 루프 상황을 방지 할 수 있는 방법은, 무한 루프를 멈추게 할 수 있는 if 조건문을 넣는 것이다. 기저조건, base case 라고도 한다. 그래서 기저 조건문를 넣는 것은 매우매우 중요하다.&lt;/p&gt;

&lt;h3 id=&quot;2-새로운-input&quot;&gt;2. 새로운 input&lt;/h3&gt;
&lt;p&gt;나머지 한가지는, 재귀함수를 호출 할 땐, 다른 parameter(input, argument)를 넣어야 한다. 만약 같은 값으로 넣게되면 리턴하는 값도 같아져서 결국 maximum callstack exceeded  에러를 만나게 될 것이다.&lt;/p&gt;

&lt;h3 id=&quot;3-resursion-에서&quot;&gt;3. Resursion 에서&lt;/h3&gt;
&lt;p&gt;다음 포스트에선 재귀알고리즘을 푸는 접근법과 다양한 예제를 설명할 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;참고자료&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;도서 - 배세민, 2019, 자바 스크립트로 하는 자료 구조와 알고리즘, 에이콘출판&lt;/li&gt;
  &lt;li&gt;Udemy - Colt Steel, JavaScript Algorithms and Data Stucture Masterclass&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hyunsu Joo</name></author><category term="JavaScript" /><category term="DataStructure/Algorithm" /><category term="resursion" /><summary type="html">오타나 설명이 잘 못되었다거나 보충설명이 필요하시다고 생각되시면 댓글 남겨 주세요 언제든지 환영입니다 😄</summary></entry><entry><title type="html">[DataStructure/Algorithm] JavaScript 스택(Stack)</title><link href="https://sooster910.github.io/2020/10/18/algorithm-stack.html" rel="alternate" type="text/html" title="[DataStructure/Algorithm] JavaScript 스택(Stack)" /><published>2020-10-18T00:00:00+00:00</published><updated>2020-10-18T00:00:00+00:00</updated><id>https://sooster910.github.io/2020/10/18/algorithm-stack</id><content type="html" xml:base="https://sooster910.github.io/2020/10/18/algorithm-stack.html">&lt;h2 id=&quot;stack&quot;&gt;Stack&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/stack.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택은 데이터를 넣을 수 있는 선형(linear) 자료형이다. 
위에 그림에서 스택에 1,2가 모두 있는 상태에서, 1에 접근 하기 위해선,맨 마지막에 추가한 2를 제거한 후에 접근할 수 있다. 그래서 LIFO(last in first out).&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;스택의 장점 : 속도가 빠르다 O(1) .
스택의 한계 : 배열과 달리 마지막에 추가된 항목외에는 직접 접근할 수가 없다. (ex: 1이란 값을 바로 접근 하지못하고, 2를 제거한후에 1에 접근가능)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;스택이-쓰이는-경우&quot;&gt;스택이 쓰이는 경우,&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Managing function invocations&lt;/li&gt;
  &lt;li&gt;Undo/Redo&lt;/li&gt;
  &lt;li&gt;Routing (the history object ) is treated like a stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;구현&quot;&gt;구현&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;getBuffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//shallow copy&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myStack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//3&lt;/span&gt;
        
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1,2]&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Hyunsu Joo</name></author><category term="JavaScript" /><category term="DataStructure/Algorithm" /><category term="Stack" /><summary type="html">Stack</summary></entry><entry><title type="html">Integration Testing with jest &amp;amp; puppeteer[1]</title><link href="https://sooster910.github.io/2020/10/12/IntegrationTesting.html" rel="alternate" type="text/html" title="Integration Testing with jest &amp;amp; puppeteer[1]" /><published>2020-10-12T00:00:00+00:00</published><updated>2020-10-12T00:00:00+00:00</updated><id>https://sooster910.github.io/2020/10/12/IntegrationTesting</id><content type="html" xml:base="https://sooster910.github.io/2020/10/12/IntegrationTesting.html">&lt;ul&gt;
  &lt;li&gt;puppeteer와 Jest를 공부하며 남긴 글입니다. 오타나 설명이 잘 못되었다거나 조금 더 보충설명이 필요하시다고 생각되시면 댓글 남겨 주세요 언제든지 환영입니다 😄&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;#puppeteerjest&quot;&gt;1.puppeteer + Jest&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#npm-run-test-실행환경-구축&quot;&gt;2. npm run test 실행환경 구축 &lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#headless-chromium-테스트-코드로-오픈하기&quot;&gt;3. headless chromium 테스트 코드로 오픈하기&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#drydont-repeat-yourself&quot;&gt;4. beforeEach( ), afterEach( ) 이용하여 리팩토링&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;#test-case-작성&quot;&gt;5. Jest test case 작성&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;puppeteerjest&quot;&gt;puppeteer+Jest&lt;/h2&gt;

&lt;p&gt;puppeteer의 공식문서에 따르면, puppeteer는 Chrome/Chromium browser를 제어할 수 있는 API를 제공하는 노드 환경에서의 라이브러리 이다. puppeteer는 기본적으로 headless Chrome/Chromium 를 제공하지만, non-headless Chrome도 제공한다. 
여기서 말하는 headless Chrome/Chromium browser는 일반적으로 우리가 아는 Chrome 브라우저와는 조금 다른, UI가 없는 환경의 브라우저 이다. 그럼 UI가 없는 브라우저는 어디에 쓰일까? headless chromium 브라우저는 normal browser 보다 빠르기 대문에, 바로 우리의 웹을 테스트 할 수 있는 환경에 적합하다, puppeteer API를 사용하여 headless Chrome/Chromium 에서 버튼 클릭, 키보드 인풋 등 브라우저 안에서 UI와 관련한 동작을 할 수 있고 이 뿐만 아니라 크롤링, 스크린샷 등등 을 할 수 있다.
하지만 puppeteer는 테스트 프레임 워크도 아니고, 테스트를 위해 만들어진 것도 아니다. 그래서, 여기에 Jest, enzyme, Mocha or Chai 와 같은 테스트 라이브러를 이용하여 실제 테스트 코드를 작성한다.&lt;/p&gt;

&lt;h2 id=&quot;npm-run-test-실행환경-구축&quot;&gt;npm run test 실행환경 구축&lt;/h2&gt;
&lt;p&gt;Test를 할 환경을 구축하기 위해 필요한 것은, 테스트 할 파일이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/__test__&lt;/code&gt; directory 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/__test__/header.test.js&lt;/code&gt; 파일을 생성한다&lt;/p&gt;

&lt;p&gt;package.json 에 이 snippet을 추가한다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;scripts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;jest&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;package.json 파일에 있는 scripts 는 npm으로 실행시키는 명령어를 개발자에 맞게 설정할 수 있는 부분이다. 즉 콘솔에서 명령어를 입력하면, script에서 이 명령어를 읽어들여 실행 시키게 된다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm run test&lt;/code&gt; 를 입력하면 프로젝트 내부의 test.js 또는 spec.js 확장자를 가지는 파일을 실행한다.&lt;/p&gt;

&lt;p&gt;puppeteer 설치&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;puppeteer&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;yarn add puppeteer&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jest 설치&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jest&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;yarn add jest&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;headless-chromium-테스트-코드로-오픈하기&quot;&gt;headless chromium 테스트 코드로 오픈하기&lt;/h2&gt;

&lt;p&gt;chromium을 실행하기위해선, puppeteer가 필요하다. puppeteer는 다양한 function을 제공하는데 , 그중에 우리가 필요한 브라우저를 오픈하기 위한 함수도 포함되어있다. 기본적으로 퍼페티어에선 launch() 가 browser객체를 리턴하고 있고, 또한  browser(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;browser&lt;/code&gt;) 객체를 이용해 우리는 또 다른 브라우저안에 브라우저 탭이라는 객체(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page&lt;/code&gt;)를 생성한다. 이 브라우저 탭 객체(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page&lt;/code&gt;)는 말그대로 크롬 브라우저의 각각의 탭을 의미하는데, 이 탭 객체(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page&lt;/code&gt;)를 이용하여, 다른 페이지로 이동 할 수도 있고, 요소들을 클릭하게 하는 테스트를 할 수 있다. 거의 모든 테스트들이 이 탭 객체(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page&lt;/code&gt;)과 상호작용하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/__test__/header.test.js&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;puppeteer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;puppeteer&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;We can launch a browser&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;puppeteer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;headless&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;headless&lt;/code&gt; option을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;로 지정해준다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;headless&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;이면 user interface가 없는 브라우저를 오픈하고, false 일 경우 user interface가 있는 브라우저를 오픈한다. 
일단은, 브라우저 오픈 여부에 대한 테스트를 위해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;headless:false&lt;/code&gt;로 지정한다.&lt;br /&gt;
puppeteer는 asynchronous기반이다. 예를 들어 ,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;browser&lt;/code&gt; 의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;puppeteer.launch()&lt;/code&gt;를 했을 때, 브라우저가 정확히 언제 오픈을 하는지 예측할 수가 없기 때문에 비동기 방식인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await&lt;/code&gt; 을 이용한다. 마찬가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;browser.newPage()&lt;/code&gt;도 새로운 tab을 열기 까지 수행되는 시간을 알 수 없으므로 비동기방식으로 실행된다.&lt;/p&gt;

&lt;p&gt;Test 실행&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/puppeteer1.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm run test&lt;/code&gt; 후에, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;header.test.js&lt;/code&gt; 파일에서 1개의 테스트 코드를 실행하여 성공했다는 로그가 나오고, 
작업표시줄에 chromium 브라우저가 생성되는 것을 볼 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{headless:false}&lt;/code&gt; 의 결과로, 실제 브라우저가 launch 되었고, 앞으로의 테스트에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{headless:true}&lt;/code&gt;로 쓸 것이다. 그 이유는, headless는 user interface가 없기 때문에 더 빠르다.&lt;/p&gt;

&lt;h2 id=&quot;drydont-repeat-yourself&quot;&gt;DRY(Don’t Repeat Yourself)&lt;/h2&gt;

&lt;p&gt;Brwoser를 열고 새로운 tab에 들어가, localhost:3000으로 이동하는 이 과정은 
앞으로 내가 작성할 모든 테스트에서 이뤄지는 중복되는 일이다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeEach()&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterEach()&lt;/code&gt;가 중복을 해결하는데 도움이 된다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeEach()&lt;/code&gt;는 테스트 파일의 각 테스트 코드가 돌기 전에 실행되는 Jest API로써, 반복되는 코드에 적합하다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterEach()&lt;/code&gt;는 반대로 테스트 코드가 돌고 난 후에 실행되는 Jest API이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeEach()&lt;/code&gt;에서 자동으로 브라우저를 오픈 했듯이, 테스트 코드를 돌고 난 후 브라우저를 자동으로 닫아주는 로직이 적합하다.&lt;/p&gt;

&lt;p&gt;이 두 API를 이용하여 코드를 리팩토링 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;beforeEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;puppeteer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;headless&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
     &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;goto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;localhost:3000&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//use await becuase navigate to somewhere take some amount of time&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;afterEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;test-case-작성&quot;&gt;Test case 작성&lt;/h2&gt;

&lt;p&gt;테스트 내용 :&lt;/p&gt;

&lt;p&gt;browser를 띄웠을 때, nav element에 있는 브랜드 이름이 ‘BLOGGY’가 맞는지 확인.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/test1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;puppeteer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;puppeteer&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;puppeteer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;headless&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
     &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;goto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;localhost:3000&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//use await becuase navigate to somewhere take some amount of time&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;afterEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Can get brand logo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;a.brand-logo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHTML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toMatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/bloggy/gi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;test를 실행시키면, puppeteer의 브라우저 인스턴스가 localhost:3000으로 띄우고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.brand-logo&lt;/code&gt; element를 찾아, innerHTML을 text라는 변수에 담아둔다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect()&lt;/code&gt;는 테스트할 대상을 넣는 api로, 여기서는 text라는 변수를 테스트 할 것이므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect(text)&lt;/code&gt;로 쓴다. 
테스트 할 대상을 알았으므로, 그 테스트의 예상이 어떻게 되어야 한다는 결과도출에 대한 method를 작성해야 한다.
우리의 테스트는, text 변수에 담긴 value 가 BLOGGY 와 일치한지 테스트 하는 것이므로, 일치한지에 대한 method를 사용한다. Jest 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect()&lt;/code&gt;에 대한 다양한 method를 제공하는데, 이 예제의 경우에는 대문자, 소문자에 상관없이 테스트 하고 싶었기에 regex를 사용하게 된다. regex를 지원하는 method는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.toMatch(rejexp)&lt;/code&gt;가 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/match할 letter/&lt;/code&gt;뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gi&lt;/code&gt; 가 붙으면, 대.소문자를 구분 하지 않는다는 정규표현식이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm run test&lt;/code&gt; 로 테스트를 하게 되면, chromium browser가 자동으로 오픈하여, 브랜드 이름을 찾는 테스트를 실행하고 테스트 결과를 log로 나타내고, 테스트가 끝나면 browser가 닫히게 된다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;참고자료 :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pptr.dev/&quot;&gt;puppeteer docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jestjs.io/docs/en/expect&quot;&gt;Jest docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://joshua1988.github.io/vue-camp/testing/jest-testing.html#jest-%EC%86%8C%EA%B0%9C&quot; target=&quot;_blank&quot;&gt;https://joshua1988.github.io 님의 블로그 중 Unit testing with Jest&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/lhZOFUY1weo&quot; target=&quot;_blank&quot;&gt;Youtube : The power of Headless Chrome and browser automation (Google I/O ‘18)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hyunsu Joo</name></author><category term="IntegrationTesting" /><category term="Jest" /><category term="puppeteer" /><summary type="html">puppeteer와 Jest를 공부하며 남긴 글입니다. 오타나 설명이 잘 못되었다거나 조금 더 보충설명이 필요하시다고 생각되시면 댓글 남겨 주세요 언제든지 환영입니다 😄</summary></entry><entry><title type="html">[DataStructure/Algorithm] Two Sum - LeetCode</title><link href="https://sooster910.github.io/2020/10/10/algo-twosum.html" rel="alternate" type="text/html" title="[DataStructure/Algorithm] Two Sum - LeetCode" /><published>2020-10-10T00:00:00+00:00</published><updated>2020-10-10T00:00:00+00:00</updated><id>https://sooster910.github.io/2020/10/10/algo-twosum</id><content type="html" xml:base="https://sooster910.github.io/2020/10/10/algo-twosum.html">&lt;h3 id=&quot;문제&quot;&gt;문제&lt;/h3&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Input: nums = [2,7,11,15], target = 9

Output: [0,1]

Output: Because nums[0] + nums[1] == 9, we return [0, 1].

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-brute-force--on&quot;&gt;1. Brute Force — O(n²)&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
생각한 첫번째 방법은 모든 수를 대입하여 9가 나오는지 확인하는 방식이다.&lt;br /&gt;
for loop에서 i=0 일 때, j loop을 한번 씩 더 돌게 하여, array안에 있는 숫자들을 다 더해 보게 된다.&lt;br /&gt;
그림으로 나타내면 이렇다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/twosome.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getTwoSum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getTwoSum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; Output [ 0, 1 ]&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-a-better-time-complexity-solution-with-hash-map--on&quot;&gt;2. A better time complexity solution with Hash Map- O(n)&lt;/h3&gt;
&lt;p&gt;일단 nested loop을 사용하지 않는 방법을 생각했다. &lt;br /&gt;
첫번 째 인덱스의 값인 (arr[0]), 2 부터 시작하여 매칭하는 값과 더하여 9가 나오는 과정을 생각하니, lookup을 하게 되므로 Map객체를 이용하는게 효율적이라 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/twosum2.jpg&quot; alt=&quot;image&quot; /&gt;
loop을 시작했을 때, 
arr[0] = 2 이고 , 2+x=9 ,  x =7 이다.&lt;br /&gt;
Map 객체에 x 의 값인 7 이 있는지 확인한다. 만약 7이 없다면 Map에 넣어주고 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map.set()&lt;/code&gt;), 7이 있다면 
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[현재 인덱스, 7에 대응 하는 value 값]&lt;/code&gt; 을 리턴한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;



&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getTwoSum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;diff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;getTwoSum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//[0,1]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Hyunsu Joo</name></author><category term="DataStructure/Algorithm" /><category term="JS" /><summary type="html">문제 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. ```</summary></entry><entry><title type="html">첫 블로그 😁</title><link href="https://sooster910.github.io/2020/10/08/first-post.html" rel="alternate" type="text/html" title="첫 블로그 😁" /><published>2020-10-08T00:00:00+00:00</published><updated>2020-10-08T00:00:00+00:00</updated><id>https://sooster910.github.io/2020/10/08/first-post</id><content type="html" xml:base="https://sooster910.github.io/2020/10/08/first-post.html">&lt;p&gt;책장을 넘기는 촉감을 좋아한탓에 책만큼은 사서 읽으려는 하는 편이다.&lt;/p&gt;

&lt;p&gt;그래서 한국에 와서 처음으로 간 곳은 교보문고 서점, 자서전이나 자기계발 책들을 그렇게 썩 좋아하는 편은 아니나,
오랜만에 서점을 와서 그런지 직관적인 제목이 눈에 띄였다. “성공하는 프로그래밍 공부법”, 훗 이런 제목이 있었네 하며 펼쳐들었는데
그자리에 서서 몇 십장의 책장을 넘기고 있는 나를 보았다. 
그 잠깐 읽는 와중에 정말 눈의 띄였던 구절은 소프트웨어 장인 정신에 대한 내용이었는데,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;동작하는 소프트웨어뿐만 아니라, 
	정교하고 솜씨 있게 만들어진 작품을,
	
변화에 대응하는 것뿐만 아니라,
	계속해서 가치를 더하는 것을,
	
개별적으로 협력하는 것뿐만 아니라,
	프로페셔널 커뮤니티를 조성하는 것을,
	
고객과 협업하는 것뿐만 아니라, 
	생산적인 동반자 관계를,&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 구절은 애자일 선언문을 기반으로 만들어진 것이라고 한다. 
“~아니라”의 구문은 부끄럽게도 내 생각의 범위와도 같은것 같다.
하지만 이 글을 본 순간 왠지 모르게 공감이 되는건 뭔가 내가 지향하고픈 가치관이 아닐까..
아직 일년차 디벨로퍼로써 정교하고 솜씨 있게 만들어진 작품이라는게 정말 깊게 어떤걸 의미하는 건 진 잘 모르겠지만 아마도 내가 이런 글에 공감을 하고 있다는건, 뭔진 잘 모르지만 그 부분을 앞으로 개발자로서 알아가게 되는 길이 아닐까 하고 생각한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;바로잡고 싶은 습관이 있다. 프로젝트나 회사일을 할 때, 그 때 순간에만 해결하고 항상 나중에 공부해야지 해놓고 북마크만 해놓는.. 아주 좋지 않은 습관 😱 
그래서 새로 알게 된 지식들, 부딪히며 문제로 안고있었던 점 들, 결국 해결해내는 일들 등을 기록으로 남기면서 5년 후에, 10년후의 개발자로서 기초가 탄탄하고 유연하게 문제 해결을 잘 해 낼 수있는 그런 개발자가 되고싶다.&lt;/p&gt;</content><author><name>Hyunsu Joo</name></author><category term="welcome" /><category term="끄적끄적" /><summary type="html">책장을 넘기는 촉감을 좋아한탓에 책만큼은 사서 읽으려는 하는 편이다.</summary></entry></feed>